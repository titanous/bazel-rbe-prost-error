use std::collections::BTreeMap;

/// Used to create a tree-like heirarchy, representing rust modules, with their content generated by
/// prost-build.
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Module<'build> {
    /// The name of the module.  This might be nested as a sub module under another module.
    /// Only the root module of the crate is expected to be None for name.
    name: Option<&'build str>,

    /// What should be put in the module scope
    content: Option<&'build str>,

    /// Modules which should be nested as submodules in this one, after the content is written out.
    /// a BTreeMap is used to keep a consistent ordering and the map is used to allow the
    /// submodules to be editable in place as the tree is being constructed, and ensure that there
    /// is only one Module struct per name.
    submodules: BTreeMap<&'build str, Module<'build>>,
}

/// Implements a consuming builder pattern for construction.  Is consuming so that each Module can
/// constructed in final form without intermediate mutable state.
impl<'a> Module<'a> {
    /// Constructs a module that can be used as the root of a module hierarchy.  Each module can
    /// have a name, content, and submodules.  If the module does not have a name, it is treated as
    /// the root module in a crate.  The content, if it exists, is the first thing printed.  The
    /// submodules are then nested in the module afterwards.
    pub fn new() -> Module<'a> {
        Module {
            name: None,
            content: None,
            submodules: BTreeMap::new(),
        }
    }

    /// Set the name of the module.  The root module will have none.
    pub fn name(mut self, name: &'a str) -> Module<'a> {
        self.name = Some(name);
        self
    }

    /// Set the contents of the module to be a particular value.  For the root module, this will
    /// show up as a header for the file.
    pub fn content(mut self, content: &'a str) -> Module<'a> {
        self.content = Some(content);
        self
    }

    /// Constructs a |Module| from the full module name.  Prost-build outputs module names as a
    /// vector of strings.  A module specified by std::io::env, would be passed as
    /// vec!["std", "io", "env"].  There is no ordering to how these modules are provided by the
    /// library, so only std::io::env could be provided, and we will need to create a node in the
    /// tree for each part.
    pub fn add_submodule(mut self, module_name: &'_ [&'a str], content: &'a str) -> Module<'a> {
        module_name
            .iter()
            .fold(&mut self, |current, name| {
                // This returns the Module we want to work with on the next step of the fold by
                // retrieving or creating the appropriate submodule.  Since the structure is
                // recursive, we run the same thing each time for each part of the full module name.
                current.submodules.entry(name).or_insert_with(|| {
                    // Intermediate modules have no content by default.
                    Module::new().name(name)
                })
            })
            // Now we can set the content, but do it in a non-consuming manner
            .content = Some(content);

        // Return back the top level module that we took in.
        self
    }

    /// Generates the single combined output of all of the rust modules starting at the current node
    /// of the hierarchy.
    pub fn output(&self) -> String {
        let mut output = String::new();
        self.output_impl(&Indent::root(), &mut output);
        output
    }

    /// Adds in the code generation for the |Module| to the end of |output| at the specified
    /// |indent| level.
    fn output_impl(&self, indent: &Indent, output: &mut String) {
        // The root module, which would create the crate, does not have a module name.
        if let Some(name) = self.name {
            indent.append(output);
            output.push_str(format!("pub mod {} {{\n", name).as_str());
        }

        let nested_indent = indent.nested();
        if let Some(content) = self.content {
            for line in content.lines() {
                // Don't add whitespace to blank lines.
                if !line.is_empty() {
                    nested_indent.append(output);
                    output.push_str(line);
                }
                output.push_str("\n");
            }
        }
        // recursively add in the sub modules.  The recursive implementation tends to make the
        // expression of the start/end of the module, particularly brackets, a little cleaner.
        self.submodules.values().for_each(|x| {
            x.output_impl(&nested_indent, output);
        });

        // Again, if we didn't add a "pub mod #name# {" line, then we shouldn't close the module.
        if self.name.is_some() {
            indent.append(output);
            output.push_str("}\n");
        }
    }
}

/// Helper struct to handle indentation.
struct Indent {
    depth: i32,
}

impl Indent {
    /// Assume a four space indent.
    const INDENT: &'static str = "    ";

    /// Create a new object, for the root of a crate, where neither the contents nor the module
    /// declarations are indented.
    pub fn root() -> Indent {
        Indent { depth: -1 }
    }

    /// Add the appropriate number indentations to the end of a string.
    pub fn append(&self, output: &mut String) {
        for _ in 0..self.depth {
            output.push_str(Indent::INDENT);
        }
    }

    /// Get the necessary Indent for a nested section.  This just increments the depth.
    pub fn nested(&self) -> Indent {
        Indent {
            depth: self.depth + 1,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn build_tree() {
        let tree = Module::new()
            .add_submodule(&["google", "protobuf"], "")
            .add_submodule(&["google", "protobuf", "compiler"], "")
            .add_submodule(&["devices"], "");

        let mut expected = Module {
            name: None,
            content: None,
            submodules: BTreeMap::<&str, Module>::new(),
        };
        expected
            .submodules
            .entry("devices")
            .or_insert(Module::new().name("devices").content(""));
        expected
            .submodules
            .entry("google")
            .or_insert(Module::new().name("google"))
            .submodules
            .entry("protobuf")
            .or_insert(Module::new().name("protobuf").content(""))
            .submodules
            .entry("compiler")
            .or_insert(Module::new().name("compiler").content(""));

        assert_eq!(tree, expected);
    }

    #[test]
    fn check_output() {
        let output = Module::new()
            .content("\nextern crate prost;\n\n")
            .add_submodule(&["google", "protobuf"], "struct A{}")
            .add_submodule(&["google", "protobuf", "compiler"], "struct B{}")
            .add_submodule(&["devices"], "struct C{}")
            .add_submodule(
                &["devices", "uploader", "session"],
                "struct D{}\n\nstruct E{}",
            )
            .output();

        let expected = r#"
extern crate prost;

pub mod devices {
    struct C{}
    pub mod uploader {
        pub mod session {
            struct D{}

            struct E{}
        }
    }
}
pub mod google {
    pub mod protobuf {
        struct A{}
        pub mod compiler {
            struct B{}
        }
    }
}
"#;
        assert_eq!(output, expected);
    }
}
