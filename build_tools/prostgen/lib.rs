mod extern_path;
mod module;

use extern_path::{ExternPath, ExternPathSetArg};
use module::Module;
use std::collections::HashMap;
use std::path::PathBuf;
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
#[structopt(name = "Prostgen", about = "Generates protobuf code using prost")]
pub struct ProstGen {
    /// The paths to the proto files to be processed.
    #[structopt(min_values = 1, parse(from_os_str))]
    input: Vec<PathBuf>,

    /// The directory where the output should be generated.  This will include a "lib.rs" as well as
    /// all of the prost generated include!-able output.
    #[structopt(long, short, parse(from_os_str))]
    output: PathBuf,

    /// The directories to be included in the invocation of protoc.
    #[structopt(short = "-I", long, parse(from_os_str))]
    include: Vec<PathBuf>,

    /// If stubs for GRPC services should be generated or not (not implemented)
    #[structopt(long)]
    grpc: bool,

    /// Fields that should be referenced from other crates, using prost-build's extern_path
    /// functionality.  Each path should provide a "crate_name,file_descriptor_path" pair.  These
    /// are separated by a comma.  The first part is the name of the crate that contains the
    /// prost protobuf code, and the second part is the path to a serialized file descriptor set.
    #[structopt(long, parse(try_from_str))]
    external: Vec<ExternPathSetArg>,
}

/// A multi-line header to mark autogeneration of the file.  Includes a @generated tag for
/// tools that support it.
const AUTOGENERATION_HEADER: &str = "// DO NOT EDIT: Autogenerated by prostgen\n\
                                     // @generated\n\n";

impl ProstGen {
    /// Execute the proto generation logic per the passed in command-line arguments.
    /// This will result in a single |output| file being generated from the |input| files specified.
    /// Consumes itself as a way of being conservative for any future changes that might be
    /// non-deterministic.  This could reasonably borrow self without consequence.
    pub fn run(self) -> anyhow::Result<()> {
        let config = tonic_build::configure()
            .build_client(self.grpc)
            .build_server(self.grpc)
            .out_dir(&self.output);

        let config = self
            .load_externs()?
            .iter()
            .fold(config, |config, extern_path| extern_path.apply(config));

        let mut prost_config = prost_build::Config::new();
        // Allows us to keep consistency of naming across all crates by not relying on prost_types.
        // TODO(b/158000788): revisit if this is the correct decision
        prost_config.compile_well_known_types();

        config.compile_with_config(prost_config, self.input.as_slice(), self.include.as_slice())?;

        let modules = generate_from_out_dir(&self.output)?;
        let content = build_tree(&modules).content(AUTOGENERATION_HEADER).output();

        std::fs::write(&self.output.join("lib.rs"), content)?;

        Ok(())
    }

    fn load_externs(&self) -> anyhow::Result<Vec<ExternPath>> {
        let mut out = Vec::new();
        for arg in self.external.iter() {
            out.append(&mut arg.load()?);
        }
        Ok(out)
    }
}

/// Helper function to map the output of prost-build::Config's generate function, which is
/// technically private into our module class.
fn build_tree<'a>(modules: &'a HashMap<Vec<String>, String>) -> Module<'a> {
    // Start with an initial module, and then repeatedly call add for the modules provided by
    // prost-build.
    modules
        .iter()
        .fold(Module::new(), |root, (module, content)| {
            root.add_submodule(
                module
                    .iter()
                    .map(|x| x.as_str())
                    .collect::<Vec<&'a str>>()
                    .as_slice(),
                content,
            )
        })
}

/// Emulates the output of `prost_build::Config::generate` which is a private function.  Internally,
/// prost_build takes the output of generate and does the inverse of this function.  It takes a
/// `HashMap` and writes out files for each submodule represented by the result.  This takes the out
/// dir from prost_build, walks through all of the files in the directory.  It uses the file names
/// to reconstruct the module name, and then reads in the contents of the file for the module
/// contents (which then, alas, get written back into a file).  This is our alternative to patching
/// both tonic and prost quite heavily.
fn generate_from_out_dir(output: &PathBuf) -> std::io::Result<HashMap<Vec<String>, String>> {
    let mut modules = HashMap::new();
    for entry in std::fs::read_dir(output)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            // This shouldn't really happen, as we'll be creating the directory
            continue;
        }
        // prost-build encodes the package name / module name in the file as "google.protobuf.rs"
        // for a package name of google.protobuf and module name of google::protobuf, for example.
        let name: Vec<String> = path
            .file_stem()
            .map(|x| x.to_str())
            .flatten()
            .ok_or_else(|| {
                std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Expected prost_build to create valid utf-8 filenames",
                )
            })?
            .split('.')
            .map(|x| x.to_owned())
            .collect();

        let contents = String::from_utf8(std::fs::read(path)?).map_err(|_| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Expected prost_build to create valid utf-8 file",
            )
        })?;
        modules.insert(name, contents);
    }

    Ok(modules)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_prost_build_generate_output() -> HashMap<Vec<String>, String> {
        let mut modules = HashMap::new();
        modules.insert(
            vec!["google".to_owned(), "protobuf".to_owned()],
            "hello world".to_owned(),
        );
        modules.insert(
            vec![
                "google".to_owned(),
                "protobuf".to_owned(),
                "compiler".to_owned(),
            ],
            "test".to_owned(),
        );
        modules
    }

    #[test]
    fn test_generate() {
        let tmpdir = PathBuf::from(
            // This is pretty bazel specific, but easy to change to tmpdir if needed later
            std::env::var_os("TEST_TMPDIR").expect("bazel test env variable not set"),
        );
        std::fs::write(tmpdir.join("google.protobuf.rs"), "hello world").unwrap();
        std::fs::write(tmpdir.join("google.protobuf.compiler.rs"), "test").unwrap();

        let output = generate_from_out_dir(&tmpdir).unwrap();

        let expected = test_prost_build_generate_output();
        assert_eq!(output, expected);
    }

    #[test]
    fn test_build_tree() {
        let modules = test_prost_build_generate_output();
        let tree = build_tree(&modules);

        let expected = Module::new()
            .add_submodule(&["google", "protobuf"], "hello world")
            .add_submodule(&["google", "protobuf", "compiler"], "test");

        assert_eq!(tree, expected);
    }
}
